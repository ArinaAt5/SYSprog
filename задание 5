import multiprocessing
import time
import queue

def factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

def worker(input_queue, output_queue):
    while True:
        try:
            task = input_queue.get(timeout=1)
            if task is None:
                break
            n, index = task
            result = factorial(n)
            output_queue.put((index, result))
        except queue.Empty:
            continue


def calculate_factorials_with_queues(numbers):
    num_processes = multiprocessing.cpu_count()

    # Создаем очереди
    input_queue = multiprocessing.Queue()
    output_queue = multiprocessing.Queue()

    processes = []
    for _ in range(num_processes):
        p = multiprocessing.Process(target=worker, args=(input_queue, output_queue))
        p.start()
        processes.append(p)

    for i, n in enumerate(numbers):
        input_queue.put((n, i))

    for _ in range(num_processes):
        input_queue.put(None)

    results = [None] * len(numbers)
    results_received = 0

    while results_received < len(numbers):
        try:
            index, result = output_queue.get(timeout=5)
            results[index] = result
            results_received += 1
        except queue.Empty:
            print("Таймаут при получении результатов")
            break

    for p in processes:
        p.join(timeout=1)
        if p.is_alive():
            p.terminate()

    return results

if __name__ == "__main__":
    numbers = list(range(1, 1001))

    # Многопроцессорный подход с очередями
    start_time = time.time()
    factorials_parallel = calculate_factorials_with_queues(numbers)
    parallel_time = time.time() - start_time

    print(f"Многопроцессорный подход (очереди): {parallel_time:.4f} секунд")

    for i in range(10):
        print(f"Факториал {numbers[i]} = {factorials_parallel[i]}")
